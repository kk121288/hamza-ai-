
from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

app.mount("/static", StaticFiles(directory=".", html=True), name="static")

@app.get("/", include_in_schema=False)
def root():
    return FileResponse("index.html")

class Texts(BaseModel):
    doc: str
    references: List[str]

@app.post("/check")
def check_plagiarism(payload: Texts) -> Dict:
    try:
        from sklearn.feature_extraction.text import TfidfVectorizer
        from sklearn.metrics.pairwise import cosine_similarity
        docs = [payload.doc] + payload.references
        if all(not d.strip() or len(d.strip().split()) < 2 for d in docs):
            return {"scores": [{"ref_index": i, "score": 0.0} for i in range(len(payload.references))]}
        vect = TfidfVectorizer(token_pattern=r"(?u)\b\w+\b").fit_transform(docs)
        if vect.shape[1] == 0:
            return {"scores": [{"ref_index": i, "score": 0.0} for i in range(len(payload.references))]}
        sims = cosine_similarity(vect[0:1], vect[1:]).flatten()
        results = [{"ref_index": i, "score": float(s)} for i, s in enumerate(sims)]
        return {"scores": results}
    except Exception as e:
        logger.exception("Error in /check")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/detect_ai_hf")
def detect_ai_hf(payload: Dict) -> Dict:
    text = payload.get("text", "")
    try:
        try:
            from detect_ai_hf import detect_ai_text_hf
            return detect_ai_text_hf(text)
        except Exception:
            logger.info("detect_ai_hf.detect_ai_text_hf not available, returning dummy response")
            return {"ai_probability": 0.0, "note": f"dummy response for: {text}"}
    except Exception as e:
        logger.exception("Error in /detect_ai_hf")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health", include_in_schema=False)
def health():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="127.0.0.1", port=8000, log_level="debug")
